<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Spiraling Out Of Control</title>
    </head>
    <body>
        <nav>
    
        <a href="/">
          Home
        </a>&nbsp;
    
        <a href="/about.html">
          About
        </a>&nbsp;
    
</nav>

        <h1>Spiraling Out Of Control</h1>
<p>02 May 2023</p>

<p><em>Disclaimer: This page requires a browser that supports <a
href="https://developer.mozilla.org/en-US/docs/Web/MathML#browser_compatibility">MathML</a>
and fonts that support basic mathematics symbols in order to render
correctly.</em></p>
<h2 id="i">I</h2>
<p>After a few mis-hires, one of my former employers attempted to
improve their interview processes by means of introducing a
white-boarded, pseudo-code technical component to the interview.
Management came up with a few ideas, ranging from the classic <a
href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a>, to
implementing <em>any</em> sorting algorithm, to producing a function
that generates the n’th Fibonacci number. These suggestions were then
brought to a few developers on the team (myself included) to solicit
inputs. Near unanimously, FizzBuzz was regarded as “too simple”. More
surprisingly, sorting was seen as potentially “too difficult”; perhaps
the candidate would feel pressured to recall a more complex algorithm to
impress the interviewers, only to stumble in the implementation details
and appear worse as a result. So the consensus seemed to settle around
the Fibonacci numbers. I suggested that in an interview, I’d struggle to
solve this problem for much the same reasons the sorting algorithm had
been rejected. My coworkers looked at me with confusion.</p>
<p>Once you’ve seen the truth, it isn’t easily forgotten. It sears a
place in the memory, like the afterimages of bright light in the eye.
These truths might fade slowly from conscious thought, but return ablaze
with the slightest provocation. I’m sure nearly every student who has
gone to grade school has seen a textbook with some spiraled shells
adorning the cover, and perhaps a sentence inside the book mentioning
some relationship to a mysterious sequence called the Fibonacci
numbers.</p>
<p>Perhaps shortly after these memories begin, she might start to
dreamily recall the numbers,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>8</mn><mo>,</mo><mn>13</mn><mo>,</mo><mn>21</mn><mi>…</mi></mrow><annotation encoding="application/x-tex">1, 1, 2, 3, 5, 8, 13, 21 \ldots</annotation></semantics></math>.
Perhaps she has become a long distance runner in the years between
grade-school and today’s interview. She notices that a 5k is
approximately 3 miles long, and that a half marathon (~13 miles) is 21
km. Coincidence? Someone who has spent enough time developing software
might question whether it would be more pragmatic to introduce a term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F_0 = 0</annotation></semantics></math>
to the sequence. A student of mathematics however, will likely recall a
late night of linear algebra homework, and begin to mutter strange
things about eigenvectors, as the lights in the room mysteriously grow
dim.</p>
<h2 id="ii">II</h2>
<p>Let’s make some pragmatic definitions, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>k</mi></msub><annotation encoding="application/x-tex">F_k</annotation></semantics></math>
refer to the k’th Fibonacci number, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F_0 = 0</annotation></semantics></math>
(since we’re secretly not infinitely opposed to the computer science
camp), and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">F_1 = 1.</annotation></semantics></math>
We temporarily think back to grade-school.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>,</mo></mrow><annotation encoding="application/x-tex">1 = 1+ 0, 2 = 1+1, 3 = 1+2,</annotation></semantics></math>
we pause, getting ahead of
ourselves…<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>144</mn><mo>=</mo><mn>89</mn><mo>+</mo><mn>55</mn></mrow><annotation encoding="application/x-tex">144=89+55</annotation></semantics></math>.
We know the pattern.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>k</mi></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_k = f_{k-1} + f_{k-2}</annotation></semantics></math>
(for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k&gt;2</annotation></semantics></math>).
Now that we’re a bit older, and ostensibly wiser, we recognize this as a
two dimensional recurrence, noting that the ordered pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mn>1</mn></msub><mo>,</mo><msub><mi>F</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(F_1, F_0) = (1, 0)</annotation></semantics></math>
can be transformed by a linear mapping into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mn>2</mn></msub><mo>,</mo><msub><mi>F</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(2, 1) = (F_2, F_1)</annotation></semantics></math>,
and our recurrence takes the form of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(x, y) = (x+y, x)</annotation></semantics></math>
Specifically, we can describe this linear transformation by the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">M = \begin{bmatrix}1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}</annotation></semantics></math>.
Going a step further, we confirm that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>M</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(1, 1) = M (1, 0)</annotation></semantics></math>,
that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>M</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(2, 1) = M (1, 1)</annotation></semantics></math>,
and following the pattern, (since matrix multiplication is associative)
we observe that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mi>n</mi></msub><mo>,</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>M</mi><mi>n</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">(F_n, F_{n-1}) = M^n (1, 0).</annotation></semantics></math>
<em>(Note: we’re not being too careful about the distinction between row
and column vectors in our notation. You can safely assume all vectors in
this post are column vectors.)</em> This realization should make us
curious. The entries in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>M</mi><mi>n</mi></msup><annotation encoding="application/x-tex">M^n</annotation></semantics></math>
should be all we need to produce the n’th number in the sequence. Could
there perhaps be a formula for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>M</mi><mi>n</mi></msup><annotation encoding="application/x-tex">M^n</annotation></semantics></math>?
We recall that unfortunately, exponentiating general matrices isn’t the
simplest procedure, so we begin to consider alternative solutions. Is
there perhaps some basis with respect to which T is a diagonal matrix?
We know that for a diagonal matrix,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>a</mi></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"><mo>⋱</mo></mtd><mtd columnalign="center" style="text-align: center"></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"><mi>b</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><msup><mi>A</mi><mi>n</mi></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msup><mi>a</mi><mi>n</mi></msup></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"><mo>⋱</mo></mtd><mtd columnalign="center" style="text-align: center"></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"><msup><mi>b</mi><mi>n</mi></msup></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">A = \begin{bmatrix} a &amp; &amp;  \\  &amp; \ddots &amp; \\ &amp; &amp; b \end{bmatrix}, A^n = \begin{bmatrix} a^n &amp; &amp;  \\  &amp; \ddots &amp; \\ &amp; &amp; b^n \end{bmatrix}.</annotation></semantics></math>
If so, we’re in luck, so let’s attempt to find such a basis.</p>
<p>Recalling this basis will be formed by eigenvectors (if such a basis
exists), we begin computing eigenvalues, which we will later use to find
eigenvectors.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>v</mi><mo>=</mo><mi>λ</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Tv = \lambda v</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>,</mo><mi>λ</mi><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(x+y, x) = (\lambda x, \lambda y)</annotation></semantics></math></p>
<p>Thus (by substitution)</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>y</mi><mo>+</mo><mi>y</mi><mo>=</mo><msup><mi>λ</mi><mn>2</mn></msup><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda y + y = \lambda^2 y</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>λ</mi><mn>2</mn></msup><mo>−</mo><mi>λ</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">0 = y(\lambda^2 - \lambda - 1)</annotation></semantics></math></p>
<p>We’re not particularly interested in cases where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y=0</annotation></semantics></math>,
so we will instead look for the roots of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>λ</mi><mn>2</mn></msup><mo>−</mo><mi>λ</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda^2 - \lambda - 1</annotation></semantics></math>,
which happen to be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1+\sqrt{5}}{2}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mn>1</mn><mo>−</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1-\sqrt{5}}{2}</annotation></semantics></math>
(our eigenvalues). If you’re really observant you’ll notice that these
are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mi>ϕ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-\phi^{-1}</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>
is the golden ratio, but it’s not relevant quite yet. We compute the
corresponding eigenvectors next.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>,</mo><mi>λ</mi><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(x+y, x) = (\lambda x, \lambda y)</annotation></semantics></math>
And letting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\phi = \lambda</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ϕ</mi><mi>x</mi><mo>,</mo><mi>ϕ</mi><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(x+y, x) = (\phi x, \phi y)</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>ϕ</mi><mi>x</mi><mo>−</mo><mi>ϕ</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">y = \phi x - \phi y</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><msup><mi>ϕ</mi><mn>2</mn></msup><mrow><mn>1</mn><mo>+</mo><mi>ϕ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">y = \frac{\phi^2}{1+\phi}</annotation></semantics></math>
which allows us to conclude
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y=1</annotation></semantics></math>,
and thus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">x = \phi</annotation></semantics></math>,
so our eigenvector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ϕ</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">u = (\phi, 1)</annotation></semantics></math>
corresponds to the eigenvalue
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>.
Following an identical process for our second eigenvalue
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mi>ϕ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-\phi^{-1}</annotation></semantics></math>),
we have a second eigenvector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><msup><mi>ϕ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">v = (-\phi^{-1}, 1)</annotation></semantics></math>.</p>
<p>Eigenbasis (i.e. a basis of eigenvectors; showing this does in fact
form a basis is beyond the scope of this post)in hand, we should be able
to write our first Fibonacci number (or vector in this case) as a linear
combination of the eigenbasis. Verily,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mi>u</mi><msqrt><mn>5</mn></msqrt></mfrac><mo>−</mo><mfrac><mi>v</mi><msqrt><mn>5</mn></msqrt></mfrac></mrow><annotation encoding="application/x-tex">(1, 0) = \frac{u}{\sqrt{5}} - \frac{v}{\sqrt{5}}</annotation></semantics></math>.</p>
<p>Therefore,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mi>n</mi></msub><mo>,</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>M</mi><mi>n</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><msup><mi>ϕ</mi><mi>n</mi></msup><msqrt><mn>5</mn></msqrt></mfrac><mi>u</mi><mo>−</mo><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mi>n</mi></mrow></msup><msqrt><mn>5</mn></msqrt></mfrac><mi>v</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">(F_{n}, F_{n-1}) = M^n (1, 0) =  \frac{\phi^n}{\sqrt{5}}u - \frac{(-\phi)^{-n}}{\sqrt{5}}v.</annotation></semantics></math></p>
<p>We’re only in the business of knowing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>n</mi></msub><annotation encoding="application/x-tex">F_n</annotation></semantics></math>,
so we can omit the interaction with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">F_{n-1}</annotation></semantics></math>
in the above formula, finding</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><msqrt><mn>5</mn></msqrt></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mo>−</mo><mfrac><mn>1</mn><msqrt><mn>5</mn></msqrt></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>1</mn><mo>−</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">F_n =  \frac{1}{\sqrt{5}}(\frac{1+\sqrt{5}}{2})^n  - \frac{1}{\sqrt{5}}(\frac{1-\sqrt{5}}{2})^n.</annotation></semantics></math></p>
<h2 id="iii">III</h2>
<p>Well, this is surprising. I mean, it’s not even clear that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>n</mi></msub><annotation encoding="application/x-tex">F_n</annotation></semantics></math>
takes integer values anymore. but we plug in a few test values, noting
that (up to floating point considerations, potentially we’ll discuss
this in a future article) we only get integral results. (Not to mention
that the underlying theory is sound, so the only room for error here is
in our execution.)</p>
<p>Overall, I think this is a bit too much math to expect someone to
remember off the cuff in an interview, and from my coworker’s horrified
expressions, they seemed to agree. It’s important to know your audience,
but sometimes it’s also important to rise above expectations and do the
right thing. Choosing to wear the right hat on a given day is an
important skill, but sometimes people’s skills and backgrounds cause
them to look at problems in a manner that differs wildly from what we’d
expect.</p>
<p>Walking away from this, there’s a few questions left dangling,
potentially to be explored in subsequent articles. If this were a job,
these would be great loose ends to tie up, or propose as followup
tasking.</p>
<ol type="1">
<li>Does this outperform naive implementations? DP-style
implementations?</li>
<li>How badly does floating point mess things up? (I’d guess not much,
especially for reasonably small terms, perhaps rounding to nearest
integer will always be sufficient.</li>
<li>What is this eigenvalue, why does it seem familiar. (I.E. why is the
golden ratio appearing in my spirals?</li>
</ol>


    </body>
</html>
